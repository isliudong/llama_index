# 面试记录



## 一、汉德信息一面

### 1、Java基本数据类型有哪些

整型：byte、short、int、long

浮点型：float、double

字符型：char

布尔型：boolean

### 2、Spring 7种事务传播行为有哪些

1、PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

2、PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘

3、PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

4、PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

5、PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

6、PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

### *隔离级别

**ISOLATION_DEFAULT** 
这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.

另外四个与JDBC的隔离级别相对应；

**ISOLATION_READ_UNCOMMITTED** （未提交读）
这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。 
这种隔离级别会产生脏读，不可重复读和幻像读。

**ISOLATION_READ_COMMITTED** (提交读)
保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 
这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

**ISOLATION_REPEATABLE_READ** (可重复读)
这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 
它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。

**ISOLATION_SERIALIZABLE** （序列化）
这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 
除了防止脏读，不可重复读外，还避免了幻像读。

========================================================================================

脏读：指一个事务读取了一个未提交事务的数据

不可重复读：在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.

虚读(幻读)：在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)

========================================================================================

五个隔离级别：

脏不幻(金不换)

第一个是数据库默认

第二个会出现：脏读、不可重复读、幻读

第三个会出现：不可重复读、幻读

第四个会出现：幻读

第五个全部都不会出现

========================================================================================

MySQL

mysql默认的事务处理级别是 REPEATABLE-READ，也就是可重复读

Oracle

oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。

默认系统事务隔离级别是READ COMMITTED,也就是读已提交

### 3、Java内存哪个区域不会溢出

程序计数器

### 4、线程同步方式有哪几种

线程同步的真实意思和字面意思恰好相反。线程同步的真实意思，其实是“排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。
线程同步的方法
(1)wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
(2)sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉
InterruptedException异常。
(3)notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的
唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
(4)notityAll ():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，
而是让它们竞争

5、异常树状图