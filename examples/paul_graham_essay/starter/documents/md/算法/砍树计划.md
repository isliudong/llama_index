许多程序要解决的关键问题是：快速定位特定排序项的能力。

第一类：散列

第二类：字符串查找

第三类：树算法

**二叉树:**

二叉树是每个结点最多有两个子树的树结构。

**树的用途：**

* 树：可以在辅助存储器中存储大量的数据。

* 二叉树、红黑树和伸展树：主要适用于内存中的工作。

* B树：打算用于辅助存储器，比如硬盘。

**二叉查找树：**

当使用二叉树存储大量数据时，只需遵循一条简单的规则：当使用中序遍历时，在每个节点中存储的数据的键将具有递增的顺序。

* 二叉查找树的5种基本操作：

  树创建

  树查找

  节点插入

  节点删除

  树遍历

二叉查找树删除考虑的情况要多一些。

 

* 二叉查找树的性能

  1、如果有N个随机分布的节点，平均高度应该为lgN。

  2、通过加载一组数据而得到的二叉查找树的形状不仅依赖于数据项，而且依赖于加载它们的顺序。这种类型的树没有内在的机制用于阻止子树之间的失衡。（分布不够随机）

 

**AVL平衡树**

* 平衡树：

  1、如果知道了树中数据项的使用频率，可以构建加权平均树（weight-balanced tree）。

  2、不过一般都假定数据项的使用频率相同。在这种情况下，将强制树是高度平衡的（height-balanced）；



* AVL树是一种遵守以下规则的二叉查找树：

  1、任何给定节点的子树的高度最多相差1。

* 在插入或删除之后，如果引入了失衡情况，就必须重新平衡树。

  两种修复失衡的操作：单旋转、双旋转（ll型右旋、lr型先左旋成ll再右旋；其他类似）

 

* AVL的规则作用是：

  确保树永远不会在实质上变为失衡状态，并且可以证明具有N个节点的AVL树的高度将和lgN成正比。

**红黑树**（更容易实现的一种平衡树）

* 红黑树（也是二叉查找树）：

  1、数据只存储在叶节点中（leaf）。也就是只有不带子节点的节点才会包含实际的数据，内部节点只用于引用。

  2、将每个节点都视作带有红色或者黑色。

* 颜色的确定规则：

  1、叶节点都是黑色

  2、沿着从根出发的任何路径上都不允许出现2个连续的红色节点。

  3、树的所有叶节点都必须具有相同的黑色深度，它被定义为叶节点与根节点之间的黑色节点的数量减1。

 

**伸展树**

1、相对于AVL，Splay的实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。

2、用途：

通常在任意数据结构的生命期内，执行不同操作的概率往往极不均衡，而且各操作之间具有极强的相关性，并在整体上多呈现出极强的规律性。其中最为典型的，就是所谓的“数据局部性”(data locality)，这包括两个方面的含义:

- 刚刚被访问过的元素，极有可能在不久之后再次被访问到
- 将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素的附近

 3、构建思想：

只需将刚被访问的节点，及时地“转移”至树根(附近)，即可加速后续的操作。当然， 转移前后的搜索树必须相互等价，因此使用树相关的“旋转“等价变换的操作。

**B树**

上面描述的几种树算法对于完全可以在内存中维护的数据工作得很好。

否则需要一种适用于磁盘存储器的树算法：

与访问内存中数据的速度比，访问磁盘上的数据非常慢

最好相对于相当大的数据块执行读、写操作。实际上，一次读入越多，就会做得更好。

 

磁盘存储器的限制意味着必须尝试最高效地使用大块磁盘存储器，应围绕这个来组织算法，并且就将多份数据放入每个块中。

 

所有的B树都利用了两种截然不同的块：索引块和数据块。

数据块是B树的叶节点，并且所有的数据都存储于其中。

索引块是上层块，它们只包含允许程序描绘从根到数据块中的想要记录的路径所需的足够信息。

B树的关键特性如下：

所有数据块都位于相同层

所有的索引块和数据块都包含某个最低限度的数据量。

索引块中的数据项只是键。

 

这些特性使得在某种意义上B树至少是平衡的。

由于所有的数据都处于树中的相同深度，对于树的各个部分将具有同样快的访问速度。

通常把B树描述为阶d，其中树中的每个节点都包含d~2d个键或记录。

 

保持B树平衡

当块变得太空或者太满时，就会发生问题。

太满时，必须把块分割成两块，并在块的父块中插入一个新键。一直到根块。

太空时，就会把相邻两个块合并。

 

实现B树的算法

分割和合并数据块与索引块需要做的工作很复杂，并且充斥着一些特殊情况。

不过通过几个简化假设，可以大大减小复杂性，同时实现一个令人满意的B树例程。

允许可变长度的键

允许可变长度的记录

把索引和数据保存在单独的文件中。

为实现这些特性，同时轻松应对特殊情况，应该做以下假设：

在创建数据集时，必须提供具有最大键的单个记录。不能删除这个记录，这个记录的存在意味着树永远不会为空。

树将具有固定高度，并且在创建B树时定义这个高度。

这两条假设的实际效果是：空树将包含多个索引块层以及一个最大的数据记录。

高度为4的树甚至对于最苛刻的应用程序也绰绰有余。

 

B树源代码模块

B树头文件

创建B树

打开现有的数据集

操作数据集

阻塞缓冲

驱动程序头部

示例驱动程序

 

B树的源程序好复杂啊

 

 

**B+树**

![image-20200629111055554](C:\Users\liudong\AppData\Roaming\Typora\typora-user-images\image-20200629111055554.png)

B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别

**特点**

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快

http://www.cburch.com/cs/340/reading/btree/



但是把所有的的数据按顺序一行接一行的存储在表中是不切实际的，因为在每次删除或者插入的时候要重写整个表。这使得我们想要把数据以树的方式存储。首先考虑到的是像红黑树这样的平衡二叉搜索树（balanced binary search tree），但是这对于存储在磁盘上的数据库而言意义不大。你会发现，磁盘的工作方式是通过一次读写数据的整个块，典型的是一次512字节或者4kb。而二叉搜索树的一个节点只用到这些数据中的很少一部分，因此需要找到一种和磁盘工作方式更为匹配的算法；由于B+树，由于在一个节点中可以存储d个子代和多达d-1个键。每个引用可以看作在节点的两个键之间的值。

下面是一个d=4的一个很小的树。

[![btree-6](https://images2015.cnblogs.com/blog/806053/201605/806053-20160508142320452-941183061.png)](http://images2015.cnblogs.com/blog/806053/201605/806053-20160508142319968-1622578790.png)

一个B+树需要每个叶子和根节点的距离相同，正如图中所示，其中搜索任何11个值中的一个只需涉及到从磁盘中载入3个节点（根块，第二层的块，和叶子）。

实际上，d可以更大，大到可以占满整个块。假设一个块是4kb，我们的键是4个字节的整数，每个引用是6字节文件的偏移量。

那么我们可以选择一个值使得4(d-1) + 6d ≤ 4096；结果是d ≤ 410。

一颗B+树维持下面不变的特性：

- 每个节点的引用比它的键要多1
- 所有的叶子与根节点之间的距离是相同的
- 对于每个有k个键值的非叶节点N：在第一个孩子的子树中所有的键值都要小于N的第一个键；并且在第i个孩子的子树中的键值都是在节点N的第(i-1)个键和第i个键之间。
- 根节点至少有两个娃
- 每个非叶节点和非根节点至少包含floor(d/2)个娃
- 每个叶子至少包含floor(d/2)个键
- 在叶子中出现的每个键，以从左到右有序排列

插入算法

1. 如果节点中有空位置，那么插入键/引用对到节点中
2. 如果节点已经满了，则将节点分割为两个结点，对半分配键值到两个节点。如果这个节点是叶子，取出第二个节点的最小值，并继续插入算法，然后把这个值插入到父节点。如果节点不是叶子，排除分割时中间的值，并重复插入算法，把排出的这个值插入到父节点。

Initial:
![img](http://www.cburch.com/cs/340/reading/btree/btree-0.png)

Insert 20:
![img](http://www.cburch.com/cs/340/reading/btree/btree-1.png)

Insert 13:
![img](http://www.cburch.com/cs/340/reading/btree/btree-2.png)

Insert 15:
![img](http://www.cburch.com/cs/340/reading/btree/btree-3.png)

Insert 10:
![img](http://www.cburch.com/cs/340/reading/btree/btree-4.png)

Insert 11:
![img](http://www.cburch.com/cs/340/reading/btree/btree-5.png)

Insert 12:
![img](http://www.cburch.com/cs/340/reading/btree/btree-6.png)

删除算法

1. 移除节点中需要删除的键和对应的引用
2. 如果节点仍然有足够的键和引用来满足B+树的特征，则可以停止
3. 如果节点的键太少了以至于满足不了不变性，如果它旁边同一层中最接近的节点有多余的，则重新分配这些键给这个节点和邻近节点。修复上一层代表这些节点的键，有不同的分割点。这里仅仅涉及到上一层键的改变，而不用插入或者删除键。
4. 如果节点的键太少了以至于满足不了特性，而旁边的节点也只是恰好够，然后将该节点和它的兄弟节点合并；如果节点是非叶子，我们需要将父节点的分割键整合到一起。在另外的情况下，需要对父节点重复删除算法来移除这些原来用来分隔这些合并的节点的键，直到父节点是根节点，然后从根节点移除最后的键，直到合并的节点成为新的根节点（然后这棵树的高度要比原来的少1层）。

Initial:
![img](http://www.cburch.com/cs/340/reading/btree/btree-6.png)

Delete 13:
![img](http://www.cburch.com/cs/340/reading/btree/btree-7.png)

Delete 15:
![img](http://www.cburch.com/cs/340/reading/btree/btree-8.png)

Delete 1:
![img](http://www.cburch.com/cs/340/reading/btree/btree-9.png)