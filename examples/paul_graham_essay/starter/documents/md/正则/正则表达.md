## 匹配连续出现的四组以 `.` 连接的字符串

题目：`abc.dss.sds.wer`

答案：`/^(.{3}.){3}.{3}$/g` 或者 `^(....){3}...$`

- `^` 以什么作为开头
- `$` 以什么作为结尾
- `.` 表示匹配任意字符
- `.` 转义表示匹配 `.` 字符本身

![img](http://oudfgqwcq.bkt.clouddn.com/luoyec/1524932841581.jpg)

## 匹配数字而非数字

题目：`xxXxxXxxxx`

答案：`/(d{2}D){2}d{4}/`

- `d` 表示匹配一个数字
- `D` 表示匹配非数字字符
- `()` 表示一个分组
- `{2}` 表示重复匹配两次

![img](http://oudfgqwcq.bkt.clouddn.com/luoyec/1524934463555.jpg)

## 匹配空白符

题目： `SSsSSsSS`

答案：`(S{2}s){2}S{2}`

- `S` 表示非空白符（`rntf`）都是空白符
- `s` 表示空白符

![img](http://oudfgqwcq.bkt.clouddn.com/luoyec/1524934661285.jpg)

## 匹配单词字符

单词字符包括从 `a-z A-Z 0-9` 和 `_`

- `w` 匹配单词字符
- `W` 匹配非单词字符

## 边界匹配，以什么开始，以什么结束

```
^dw{4}.$
```

匹配以数字开头的一个字符，连续四个单词字符，以 `.` 结束的字符串

![img](http://oudfgqwcq.bkt.clouddn.com/luoyec/1524937039845.jpg)

## 转换为驼峰命名

```
var s1 = "get-element-by-id";` 给定这样一个连字符串，`写一个function` 转换为驼峰命名法形式的字符串 `getElementById
var s1 = 'get-element-by-id' 

var f = function(s) {
    return s.replace(/-w+/g, function(x) {
        console.log(x)
        return x.slice(1).toUpperCase()
    })
}
```

## 判断字符串是否包含数字

```
var s1 = 'arhs 23jyfhahr 234 ag'

var f = function(s = '') {
    return /d/g.test(s)
}
```

## 判断电话号码

```
var s1 = '13898762123'

var f = function(s = '') {
    return /^1[34578]d{9}$/g.test(s)
}
```

## 判断是否符合指定格式

给定字符串 str，检查其是否符合如下格式
XXX-XXX-XXXX，其中 X 为 Number 类型

```
var s1 = '234-234-2342'

var f = function(s = '') {
    return /^(d{3}-){2}d{4}$/g.test(s)
}
```

## 判断是否符合 USD 格式

给定字符串 str，检查其是否符合美元书写格式

- 以 $ 开始
- 整数部分，从个位起，满 3 个数字用 , 分隔
- 如果为小数，则小数部分长度为 2
- 正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3**

```
var s1 = '$1,023,032.03'

var f = function(s = '') {
    return /^$d{1,3}(,d{3})*(.d{2})?$/g.test(s)
}
```

## JS 实现千位分隔符

```
function (number) {
    var regx = /d{1,3}(?=(d{3})+$)/g
    return (number + '').replace(regx, '$&,') // $&表示与regx相匹配的字符串
}
```

## 获取 url 中的参数

> `replace()` 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式,
> 替换值可以是一个字符串或者一个每次匹配都要调用的函数。
> ⚠️ 返回新的字符串，而原来的字符串不会被改变。如果第二个参数是个函数，那么函数的返回值将会替换字符串中匹配到的元素，如果第一个参数是个正则，且是全局匹配模式，那么该函数将会被多次调用，每次匹配到元素都会被执行。

`replace()` 参数：

![img](http://oudfgqwcq.bkt.clouddn.com/luoyec/1525150013967.jpg)

```
function replacer(match, p1, p2, p3, offset, string) {
    // p1 is nondigits, p2 digits, and p3 non-alphanumerics
    return [p1, p2, p3].join(' - ')
}
var newString = 'abc12345#$*%'.replace(/([^d]*)(d*)([^w]*)/, replacer)
console.log(newString) // abc - 12345 - #$*%
function getUrlParam(url, key) {
    // 解析的结果以对象行使存放
    var arr = {}

    /**
     *  字符串查找替换方法，可以传入字符串或者正则作为第一个参数
     *
     * @param {regexp} 以等号连接的，前面可以有?开始，后面可以有& 结束的
     * @param {any} matchKey 第一个圆括号匹配到的值，也就是参数等号左边的key
     * @param {any} matchValue 第而个圆括号匹配到的值，也就是参数等号右边的value
     * @returns 返回替换后的字符串，原有的字符串不会被改变
     *
     */
    url.replace(/??(w+)=(w+)&?/g, function(match, matchKey, matchValue) {
        if (!arr[matchKey]) {
            arr[matchKey] = matchValue
        } else {
            // 如果参数存在重复，则连接两个参数的值，存放在一个数组中
            var temp = arr[matchKey]
            arr[matchKey] = [].concat(temp, matchValue)
        }
    })

    // 判断第二个参数key，绝对返回内容
    if (!key) {
        return arr
    } else {
        for (ele in arr) {
            if ((ele = key)) {
                return arr[ele]
            }
        }
        return ''
    }
}

var result = getUrlParam('www.baidu.com?name=234234&age=age&name=tt')
console.log(result)
```

## 验证邮箱

```
// 'luoyecong@aliyun.com'
// ? 最多一个
// + 最少一个
// * 零个或多个

// 一个合法的邮箱地址有三部分组成，以 @  . 符号连接，每个部分需要符合 a-zA-z0-9_- 字符组成

function isEmail(email = '') {
    return /^([a-zA-Zd_-])+@([a-zA-Zd_-])+.([a-zA-Zd_-])+$/.test(email)
}

console.log(isEmail('luo23yec_-ong@ali23yun.com'))
```

## 验证合法身份证号

```
// 身份证号码可能为15位或18位，15位为全数字，18位中前17位为数字，最后一位为数字或者X

;/(^d{15}$)|(^d{18}$)|(^d{17}(d|X|x)$)/
```

## 匹配汉字

```
var regx = /^[u4e00-u9fa5]{0,}$/
```

> ⚠️ 这种匹配汉字的方法并不严谨，正确的方法是通过正则的底层提供的校验，但是需要 babel 的协助，还有汉字并不包括标点，具体请参看
> [JavaScript 正则表达式匹配汉字](https://zhuanlan.zhihu.com/p/33335629)

## 去除首尾的’/‘

```
// 以一个或者多个 / 开始或者以一个或者多个 / 结束的
var str = '/asdf//'
str = str.replace(/^/+|/+$/g, '')
```

## 判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式

```
var regx = /^d{4}-d{1,2}-d{1,2}$/
```

## 判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂）

```
var regx = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/
```

## IPv4 地址正则

```
var regx = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
```

## 十六进制颜色正则

```
var regx = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
```

## 车牌号正则

```
var regx = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/
```

## 过滤 HTML 标签

```
// 匹配一对<> 内不包括 <>  的
var str = '<p>dasdsa</p>nice <br> test</br>'
var regx = /<[^<>]+>/g
str = str.replace(regx, '')
```

## 密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符

```
// 连续使用前瞻，匹配多个符合要求的分组，在每个分组中，任意字符、字母、数字、特殊字符
var regx = /^.*(?=.{6,})(?=.*d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/
```

## URL 正则

```
var regx = /^((https?|ftp|file)://)?([da-z.-]+).([a-z.]{2,6})([/w .-]*)*/?$/
```

## 匹配标签内数据，包括标签

```
// <OPTION value="待处理">待处理</OPTION>
// 写一个正则表达式,匹配 "<OPTION value="待处理">"
var str = '<OPTION value="待处理">待处理</OPTION>'
var regx = /^<.*?>/
var resiult = regx.exec(str)[0]
```