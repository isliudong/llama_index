# java 中常见的并发工具

## 一、原子类

### 1、AtomicInteger

AtomicInteger 是一个提供原子操作的 Integer 类。通过线程安全的方式操作加减。

```java
public class AtomicIntegerTest {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(1);
        atomicInteger.getAndIncrement();
        atomicInteger.getAndAdd(2);
        atomicInteger.getAndDecrement();
        atomicInteger.getAndSet(100);
        System.out.println(atomicInteger.get());
    }
}
```

### 2、AtomicBoolean

AtomicBoolean 是一个提供原子操作的 Boolean 类。通过线程安全的方式操作 true 和 false。

```java
public class AtomicBooleanTest {
    public static void main(String[] args) {
        AtomicBoolean atomicBoolean = new AtomicBoolean(true);
        System.out.println(atomicBoolean.get());
        atomicBoolean.set(false);
        System.out.println(atomicBoolean.get());
    }
}
```

### 3、AtomicLong

AtomicLong 是一个提供原子操作的 Long 类。通过线程安全的方式操作加减。

```java
public class AtomicLongTest {
    public static void main(String[] args) {
        AtomicLong atomicLong = new AtomicLong(1L);
        atomicLong.getAndIncrement();
        atomicLong.getAndAdd(2);
        atomicLong.getAndDecrement();
        atomicLong.getAndSet(100);
        System.out.println(atomicLong.get());
    }
}
```

### 4、AtomicReference

AtomicReference 是一个提供原子操作的引用类型。通过线程安全的方式操作引用类型。

```java
public class AtomicReferenceTest {
    public static void main(String[] args) {
        AtomicReference<User> atomicReference = new AtomicReference<>();
        User user = new User();
        atomicReference.set(user);
        System.out.println(atomicReference.get());
    }
}
```

## 二、Lock

### 1、ReentrantLock

ReentrantLock 是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。

```java 
public class ReentrantLockTest {
    public static void main(String[] args) {
        ReentrantLock reentrantLock = new ReentrantLock();
        reentrantLock.lock();
        try {
            // do something
        } finally {
            reentrantLock.unlock();
        }
    }
}
```

### 2、ReentrantReadWriteLock

ReentrantReadWriteLock 是一个读写锁，它允许多个读线程同时访问，但在写线程访问时，所有读线程和写线程都会被阻塞。

```java
public class ReentrantReadWriteLockTest {
    public static void main(String[] args) {
        ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
        reentrantReadWriteLock.readLock().lock();
        try {
            // do something
        } finally {
            reentrantReadWriteLock.readLock().unlock();
        }
        reentrantReadWriteLock.writeLock().lock();
        try {
            // do something
        } finally {
            reentrantReadWriteLock.writeLock().unlock();
        }
    }
}
```

### 3、StampedLock

StampedLock 是一个乐观读锁 ，StampedLock的乐观读和普通的读锁的区别是：普通的读锁在多个线程同时读的时候，所有的写操作会被阻塞，
而 StampedLock 提供的乐观读(基于时间搓)，是允许线程获取写锁的，也就是说不是所有的写操作都被阻塞,也就是说乐观读其实是无锁的

```java
public class StampedLockTest {
    public static void main(String[] args) {
        StampedLock stampedLock = new StampedLock();
        long stamp = stampedLock.readLock();
        try {
            // do something
        } finally {
            stampedLock.unlockRead(stamp);
        }
        stamp = stampedLock.writeLock();
        try {
            // do something
        } finally {
            stampedLock.unlockWrite(stamp);
        }
    }
}
```

## 三、BlockingQueue

### 1、ArrayBlockingQueue

ArrayBlockingQueue 是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

```java
public class ArrayBlockingQueueTest {
    public static void main(String[] args) {
        ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(10);
        arrayBlockingQueue.add("1");
        arrayBlockingQueue.add("2");
        arrayBlockingQueue.add("3");
        arrayBlockingQueue.add("4");
        arrayBlockingQueue.add("5");
        arrayBlockingQueue.add("6");
        arrayBlockingQueue.add("7");
        arrayBlockingQueue.add("8");
        arrayBlockingQueue.add("9");
        arrayBlockingQueue.add("10");
        System.out.println(arrayBlockingQueue.size());
        arrayBlockingQueue.add("11");
    }
}
```

### 2、LinkedBlockingQueue

LinkedBlockingQueue 是一个基于链表结构的阻塞队列，此队列按 FIFO（先进先出）排序元素，吞吐量通常要高于 ArrayBlockingQueue。

```java
public class LinkedBlockingQueueTest {
    public static void main(String[] args) {
        LinkedBlockingQueue<String> linkedBlockingQueue = new LinkedBlockingQueue<>();
        linkedBlockingQueue.add("1");
        linkedBlockingQueue.add("2");
        linkedBlockingQueue.add("3");
        linkedBlockingQueue.add("4");
        linkedBlockingQueue.add("5");
        linkedBlockingQueue.add("6");
        linkedBlockingQueue.add("7");
        linkedBlockingQueue.add("8");
        linkedBlockingQueue.add("9");
        linkedBlockingQueue.add("10");
        System.out.println(linkedBlockingQueue.size());
        linkedBlockingQueue.add("11");
    }
}
```

### 3、SynchronousQueue

SynchronousQueue 是一个不存储元素的阻塞队列，每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。

```java
public class SynchronousQueueTest {
    public static void main(String[] args) {
        SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();
        synchronousQueue.add("1");
        synchronousQueue.add("2");
        synchronousQueue.add("3");
        synchronousQueue.add("4");
        synchronousQueue.add("5");
        synchronousQueue.add("6");
        synchronousQueue.add("7");
        synchronousQueue.add("8");
        synchronousQueue.add("9");
        synchronousQueue.add("10");
        System.out.println(synchronousQueue.size());
        synchronousQueue.add("11");
    }
}
```

### 4、PriorityBlockingQueue

PriorityBlockingQueue 是一个支持优先级排序的无界阻塞队列。

```java
public class PriorityBlockingQueueTest {
    public static void main(String[] args) {
        PriorityBlockingQueue<String> priorityBlockingQueue = new PriorityBlockingQueue<>();
        priorityBlockingQueue.add("1");
        priorityBlockingQueue.add("2");
        priorityBlockingQueue.add("3");
        priorityBlockingQueue.add("4");
        priorityBlockingQueue.add("5");
        priorityBlockingQueue.add("6");
        priorityBlockingQueue.add("7");
        priorityBlockingQueue.add("8");
        priorityBlockingQueue.add("9");
        priorityBlockingQueue.add("10");
        System.out.println(priorityBlockingQueue.size());
        priorityBlockingQueue.add("11");
    }
}
```

### 5、DelayQueue

DelayQueue 是一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。

```java
public class DelayQueueTest {
    public static void main(String[] args) {
        DelayQueue<DelayTask> delayQueue = new DelayQueue<>();
        delayQueue.add(new DelayTask("1", 1000));
        delayQueue.add(new DelayTask("2", 2000));
        delayQueue.add(new DelayTask("3", 3000));
        delayQueue.add(new DelayTask("4", 4000));
        delayQueue.add(new DelayTask("5", 5000));
        delayQueue.add(new DelayTask("6", 6000));
        delayQueue.add(new DelayTask("7", 7000));
        delayQueue.add(new DelayTask("8", 8000));
        delayQueue.add(new DelayTask("9", 9000));
        delayQueue.add(new DelayTask("10", 10000));
        System.out.println(delayQueue.size());
        delayQueue.add(new DelayTask("11", 11000));
    }
}
```

## 四、ConcurrentHashMap

ConcurrentHashMap 是一个支持高并发的 HashMap，它是通过分段锁的方式来实现的。

```java
public class ConcurrentHashMapTest {
    public static void main(String[] args) {
        ConcurrentHashMap<String, String> concurrentHashMap = new ConcurrentHashMap<>();
        concurrentHashMap.put("1", "1");
        concurrentHashMap.put("2", "2");
        concurrentHashMap.put("3", "3");
        concurrentHashMap.put("4", "4");
        concurrentHashMap.put("5", "5");
        concurrentHashMap.put("6", "6");
        concurrentHashMap.put("7", "7");
        concurrentHashMap.put("8", "8");
        concurrentHashMap.put("9", "9");
        concurrentHashMap.put("10", "10");
        System.out.println(concurrentHashMap.size());
        concurrentHashMap.put("11", "11");
    }
}
```

## 五、ConcurrentSkipListMap

ConcurrentSkipListMap 是一个支持高并发的有序的 HashMap，它是通过跳表的方式来实现的。

```java

public class ConcurrentSkipListMapTest {
    public static void main(String[] args) {
        ConcurrentSkipListMap<String, String> concurrentSkipListMap = new ConcurrentSkipListMap<>();
        concurrentSkipListMap.put("1", "1");
        concurrentSkipListMap.put("2", "2");
        concurrentSkipListMap.put("3", "3");
        concurrentSkipListMap.put("4", "4");
        concurrentSkipListMap.put("5", "5");
        concurrentSkipListMap.put("6", "6");
        concurrentSkipListMap.put("7", "7");
        concurrentSkipListMap.put("8", "8");
        concurrentSkipListMap.put("9", "9");
        concurrentSkipListMap.put("10", "10");
        System.out.println(concurrentSkipListMap.size());
        concurrentSkipListMap.put("11", "11");
    }
}
```

## 六、ConcurrentSkipListSet

ConcurrentSkipListSet 是一个支持高并发的有序的 HashSet，它是通过跳表的方式来实现的。

```java

public class ConcurrentSkipListSetTest {
    public static void main(String[] args) {
        ConcurrentSkipListSet<String> concurrentSkipListSet = new ConcurrentSkipListSet<>();
        concurrentSkipListSet.add("1");
        concurrentSkipListSet.add("2");
        concurrentSkipListSet.add("3");
        concurrentSkipListSet.add("4");
        concurrentSkipListSet.add("5");
        concurrentSkipListSet.add("6");
        concurrentSkipListSet.add("7");
        concurrentSkipListSet.add("8");
        concurrentSkipListSet.add("9");
        concurrentSkipListSet.add("10");
        System.out.println(concurrentSkipListSet.size());
        concurrentSkipListSet.add("11");
    }
}
```

## 七、CopyOnWriteArrayList

CopyOnWriteArrayList 是一个支持高并发的 ArrayList，它是通过复制的方式来实现的。

```java

public class CopyOnWriteArrayListTest {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>();
        copyOnWriteArrayList.add("1");
        copyOnWriteArrayList.add("2");
        copyOnWriteArrayList.add("3");
        copyOnWriteArrayList.add("4");
        copyOnWriteArrayList.add("5");
        copyOnWriteArrayList.add("6");
        copyOnWriteArrayList.add("7");
        copyOnWriteArrayList.add("8");
        copyOnWriteArrayList.add("9");
        copyOnWriteArrayList.add("10");
        System.out.println(copyOnWriteArrayList.size());
        copyOnWriteArrayList.add("11");
    }
}
```

## 八、CopyOnWriteArraySet

CopyOnWriteArraySet 是一个支持高并发的 HashSet，它是通过复制的方式来实现的。

```java

public class CopyOnWriteArraySetTest {
    public static void main(String[] args) {
        CopyOnWriteArraySet<String> copyOnWriteArraySet = new CopyOnWriteArraySet<>();
        copyOnWriteArraySet.add("1");
        copyOnWriteArraySet.add("2");
        copyOnWriteArraySet.add("3");
        copyOnWriteArraySet.add("4");
        copyOnWriteArraySet.add("5");
        copyOnWriteArraySet.add("6");
        copyOnWriteArraySet.add("7");
        copyOnWriteArraySet.add("8");
        copyOnWriteArraySet.add("9");
        copyOnWriteArraySet.add("10");
        System.out.println(copyOnWriteArraySet.size());
        copyOnWriteArraySet.add("11");
    }
}
```

## 九、LinkedBlockingQueue

LinkedBlockingQueue 是一个支持高并发的有界队列，它是通过链表的方式来实现的。

```java

public class LinkedBlockingQueueTest {
    public static void main(String[] args) {
        LinkedBlockingQueue<String> linkedBlockingQueue = new LinkedBlockingQueue<>();
        linkedBlockingQueue.add("1");
        linkedBlockingQueue.add("2");
        linkedBlockingQueue.add("3");
        linkedBlockingQueue.add("4");
        linkedBlockingQueue.add("5");
        linkedBlockingQueue.add("6");
        linkedBlockingQueue.add("7");
        linkedBlockingQueue.add("8");
        linkedBlockingQueue.add("9");
        linkedBlockingQueue.add("10");
        System.out.println(linkedBlockingQueue.size());
        linkedBlockingQueue.add("11");
    }
}
```

## 十、Excuator

Executor 一个线程池的接口，它有三个实现类：ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool。

```java

public class ExecutorTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        executorService.execute(() -> {
            System.out.println("hello");
        });
    }
}
```

## 十一、Semaphore

Semaphore 一个多线程的信号量，基于AQS；Semaphore 是一种用于控制并发访问的同步工具。
它维护了一个许可集，可以通过 acquire() 获取一个许可，
如果没有可用的许可，acquire() 会被阻塞，直到有可用的许可。通过 release() 方法释放许可。

```java

public class SemaphoreTest {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(10);
        try {
            semaphore.acquire();
            System.out.println("hello");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }
}
```

## 十二、CountDownLatch

CountDownLatch 用于单个线程等待多个线程直到它们完成各自的工作，然后再继续执行

```java

public class CountDownLatchTest {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(10);
        try {
            countDownLatch.await();
            System.out.println("hello");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            countDownLatch.countDown();
        }
    }
}
```

## 十三、CyclicBarrier

CyclicBarrier 用于多个线程相互等待，直到所有线程都到达了某个公共屏障点，然后再继续执行。

```java

public class CyclicBarrierTest {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(10);
        try {
            cyclicBarrier.await();
            System.out.println("hello");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
```

## 十四、Future

Future 一个异步计算的结果，它有两个实现类：FutureTask、CompletableFuture。

```java

public class FutureTest {
    public static void main(String[] args) {
        FutureTask<String> futureTask = new FutureTask<>(() -> {
            return "hello";
        });
        try {
            String s = futureTask.get();
            System.out.println(s);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

## 十五、CompletableFuture

CompletableFuture 一个异步计算的结果，它是通过 ForkJoinPool 的方式来实现的。

```java

public class CompletableFutureTest {
    public static void main(String[] args) {
        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            return "hello";
        });
        try {
            String s = completableFuture.get();
            System.out.println(s);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

## 十六、ThreadLocalRandom

ThreadLocalRandom 是 Java 中一个实用类，为线程提供随机数生成。
它是 java.util.Random 类的子类，在多线程执行时应该使用它而不是 Random 类。

```java

public class ThreadLocalRandomTest {
    public static void main(String[] args) {
        ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();
        System.out.println(threadLocalRandom.nextInt());
    }
}
```

## 十七、ThreadLocal

ThreadLocal 一个线程局部变量，它的作用是为每个线程提供一个变量副本，使得每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。

```java

public class ThreadLocalTest {
    public static void main(String[] args) {
        ThreadLocal<String> threadLocal = new ThreadLocal<>();
        threadLocal.set("hello");
        System.out.println(threadLocal.get());
    }
}
```

## 十八、AbstractQueuedSynchronizer

AbstractQueuedSynchronizer 是一个用来构建锁和同步器的框架，它使用了一个 int 成员变量来表示同步状态，
并通过内置的 FIFO 队列来完成资源获取线程的排队工作。

```java
   
public class AbstractQueuedSynchronizerTest {
    public static void main(String[] args) {
        AbstractQueuedSynchronizer abstractQueuedSynchronizer = new AbstractQueuedSynchronizer() {
            @Override
            protected boolean tryAcquire(int arg) {
                // 获取锁
                return super.tryAcquire(arg);
            }

            @Override
            protected boolean tryRelease(int arg) {
                // 释放锁
                return super.tryRelease(arg);
            }

            @Override
            protected int tryAcquireShared(int arg) {
                // 共享锁
                return super.tryAcquireShared(arg);
            }

            @Override
            protected boolean tryReleaseShared(int arg) {
                // 释放共享锁
                return super.tryReleaseShared(arg);
            }

            @Override
            protected boolean isHeldExclusively() {
                // 是否独占
                return super.isHeldExclusively();
            }
        };
    }
}
```

## 十九、FIFO

FIFO 是 First In First Out 的缩写，即先进先出。

```java

public class FIFO {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        queue.add("hello");
        queue.add("world");
        System.out.println(queue.poll());
        System.out.println(queue.poll());
    }
}
```
