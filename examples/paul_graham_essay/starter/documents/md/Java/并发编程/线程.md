1、一个方法对应一个栈帧

2、栈以线程为单位，每个线程拥有相互独立的栈

+ 线程上下文切换	

  1、线程占用 `cpu` 切换

  2、保存当前线程状态，由程序计数器记住下次恢复时该执行的指令

+ 线程常见方法

  1、start（）

  2、run（）

  3、join（）

  4、join（long num）

+ sleep（）与yield（）

  1、sleep（）运行到阻塞

  2、yield（）运行到就绪

+ 打断

  1、打断标记，自行决定

  2、stop（）退出线程

  3、System.exit()，退出进程

+ 不推荐方法

  1、stop（）停止线程

  2、suspend（）挂起暂停线程

  3、resume（）恢复线程

+ 系统层面线程状态

  1、初始

  2、就绪

  3、运行

  4、阻塞

  5、终止

+ Java层面线程状态

  ![image-20200410120918281](C:\Users\liudong\AppData\Roaming\Typora\typora-user-images\image-20200410120918281.png)

  1、NEW：创建线程未开始

  2、RUNNABLE：调用start（）后，包含三种状态如上图，因为系统层面的线程阻塞Java无法区分。

  3、BLOCKED:阻塞，如拿不到synchronized锁导致进入阻塞

  4、WAITING：等待，如join（）

  5、TIMED_WAITING：时限等待，如执行sleep（）后

  6、TERMINATED

+ 临界区

  1、含义：对共享变量读写操作的一段代码

  2、安全问题：线程切换引起指令交错进而可能导致数据错误

+ 安全问题解决

  1、阻塞式：synchronized（对象锁），Lock

  2、非阻塞式：原子变量

+ synchronized

  1、使用对象锁保证临界区的原子性

  2、加方法上实际上是锁住this类，而加在静态方法上是锁住本类对象

+ String Integer等包装类为不可变类，线程安全



+ synchronized锁优化

  1、轻量级锁

  2、锁膨胀

  3、自旋优化

  4、偏向锁

  5、锁消除

+ wait() notify()

  1、获取锁的线程才能调用

+ sleep(long n) 、wait(long n)区别

  1、sleep 是 Thread 方法，而 wait 是 Object 的方法 

  2、sleep 不需要强制和 synchronized 配合使用，但 wait 需要
  和 synchronized 一起用 

  3、 sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 

  4、它们的状态相同 TIMED_WAITING

  

+ 多线程指令重排可能导致结果异常(`cpu`流水线)

  + 原理

    指令执行单元EU是执行指令的唯一部件，一次只能执行一个指令，单核`cpu`的情况下，只有一个指令处于执行中。`cpu`中的各部分也是同时只能做一件事，但它们就像身体器官一样，也是在并行工作，相当于多个“人手”。`cpu`的指令执行过程分为取指令、译码、执行三个步骤。每个步骤都是独立执行的，`cpu`可以可以一边执行指令，一边取指令，一边译码。`cpu`中的时序不是秒，对`cpu`来说，秒就是天文数字。它的时序是时钟周期。按照这三个步骤，其三级流水线如表

    ![img](https://img-blog.csdnimg.cn/20190627145912475.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Npbm9sb3Zlcg==,size_16,color_FFFFFF,t_70)

     
  
    以上在第2周期后，都有指令在执行，这是最基本的流水线啦。为了更好的理解以后的分支预测，**注意**：虽然在一个时钟周期内`cpu`同时干了三件事，但一定要清楚，这三件事不属于同一个指令，是三个指令重叠在一起了，这和砸钉子的流水线是一样的道理。同时完成的是当前指令的第三步、下一条指令的第二步，第三条指令的第一步。`cpu`中每条指令必须经过取指、译码、执行三步才算完成。
  
  + 解决
  
    在最后一条指令变量添加volatile
  
  + 例如
  
    ```java
    // 线程1 执行此方法
    //把ready声明为volatile变量即可禁用指令重排
    public void actor1(I_Result r) {
    if(ready) {
    r.r1 = num + num;
    } else {
    r.r1 = 1;
    }
    }
    // 线程2 执行此方法
    public void actor2(I_Result r) {
    //此处如果指令重排导致r1=0
    num = 2;
    ready = true;
    }
    ```

+ volatile

  + 保证可见性
  + 保证有序性

  + 原理：内存屏障，即加入读写屏障
    + 写屏障：屏障之前的改动同步同步到主存中，并且避免指令重排
    + 读屏障：屏障之后的读取，加载主存中数据，并且避免指令重排

+ T t = new T();
  + 不是原子操作，若指令重排则导致实例在实例化前将引用赋值给变量；在多线程环境下，可能导致t=null
  + 使用volatile可解决

+ 